<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 深入学习下AJAX · 信鑫-King's Blog</title><meta name="description" content="深入学习下AJAX - Kylin King"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://www.ycjcl.cc/atom.xml" title="信鑫-King's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/ycjcl868" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/ycjcl868" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">深入学习下AJAX</h1><div class="post-info">Jul 8, 2018</div><div class="post-content"><blockquote>
<p>AJAX虽说是最早接触的，但一直只停留在业务层面，没能对其内部进行深究，今天就对AJAX和JSONP深入学习下。</p>
</blockquote>
<h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><p><a href="https://zh.wikipedia.org/wiki/AJAX" target="_blank" rel="noopener">AJAX维基百科解释</a></p>
<h3 id="二、核心对象XMLHttpRequest"><a href="#二、核心对象XMLHttpRequest" class="headerlink" title="二、核心对象XMLHttpRequest"></a>二、核心对象XMLHttpRequest</h3><blockquote>
<p>The XMLHttpRequest.abort() method aborts the request if it has already been sent. When a request is aborted, its readyState is set to 0 (UNSENT), but the readystatechange event is not fired (译文：XMLHttpRequest 是一个API, 它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。)</p>
</blockquote>
<p><img src="http://7xi72v.com1.z0.glb.clouddn.com/17-2-15/65992791-file_1487145378879_ef8e.png" alt=""></p>
<p>该对象请求是<strong>异步执行</strong>的，所以要通过<strong>回调函数(onreadystatechange)</strong>获得响应，对象主要是通过<code>open()</code>、<code>send()</code>、方法并组合<code>readyState</code>、<code>status</code>、<code>responseText</code>属性来完成的。 下面来说下<code>AJAX</code>步骤：</p>
<h3 id="三、步骤"><a href="#三、步骤" class="headerlink" title="三、步骤"></a>三、步骤</h3><h4 id="①-创建兼容的XMLHttpRequest对象"><a href="#①-创建兼容的XMLHttpRequest对象" class="headerlink" title="① 创建兼容的XMLHttpRequest对象"></a>① 创建兼容的XMLHttpRequest对象</h4><p>该对象需要兼容下浏览器(毕竟奇葩的 IE)，通用的兼容方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跨浏览器兼容</span></span><br><span class="line"><span class="keyword">var</span> xhr;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> XMLHttpRequest != <span class="string">"undefined"</span>)&#123;</span><br><span class="line">	xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">window</span>.ActiveXObject)&#123;</span><br><span class="line">	<span class="keyword">var</span> aVersions = [<span class="string">"Microsoft.XMLHttp"</span>,<span class="string">"Msxml2.XMLHttp.5.0"</span>,<span class="string">"Msxml2.XMLHttp.4.0"</span>,<span class="string">"Msxml2.XMLHttp.3.0"</span>,<span class="string">"Msxml2.XMLHttp"</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;aVersions.length;i++)&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			xhr = <span class="keyword">new</span> ActiveXObject(aVersions);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;<span class="keyword">catch</span>(e)&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="②-初始化连接open"><a href="#②-初始化连接open" class="headerlink" title="② 初始化连接open()"></a>② 初始化连接open()</h4><p><code>xhr.open(method,url[,async, user, password])</code>，有三个参数，<code>method</code>有<code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code>方法，<code>url</code>是数据接口地址，<code>async(可选)</code>是否异步(<code>true</code>(默认)/<code>false</code>)，<code>user(可选)、password(可选)</code>使用的比较少。</p>
<p>然后建立连接：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(<span class="string">'GET'</span>,<span class="string">'http://localhost:3000/api/test'</span>);</span><br></pre></td></tr></table></figure>
<h4 id="③-发送请求send"><a href="#③-发送请求send" class="headerlink" title="③ 发送请求send()"></a>③ 发送请求send()</h4><p><code>xhr.send(data)</code>，<code>data</code>可以是任意类型的数据，若是<code>GET</code> 请求方式，<code>data</code>可以为空/<code>null</code>。</p>
<p>发送请求：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlHttp.send();</span><br></pre></td></tr></table></figure>
<h4 id="④-等待回调结果"><a href="#④-等待回调结果" class="headerlink" title="④ 等待回调结果"></a>④ 等待回调结果</h4><p>使用<code>onreadystatechange</code>回调函数，处理数据各种状态。当<code>readyState</code>为4，且<code>status</code>为200时，就返回成功。其它状态请参考下图。</p>
<p><code>readyState</code>码：</p>
<p><img src="http://7xi72v.com1.z0.glb.clouddn.com/17-2-15/50710653-file_1487145412385_5308.png" alt=""></p>
<p>HTTP状态码(<code>status</code>)：</p>
<p><img src="http://7xi72v.com1.z0.glb.clouddn.com/17-2-15/14231422-file_1487144870551_12d0c.png" alt=""></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 状态发生变化时，函数被回调</span></span><br><span class="line">	<span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123; <span class="comment">// 成功完成</span></span><br><span class="line">		<span class="comment">// 判断响应结果：</span></span><br><span class="line">		<span class="keyword">if</span>(xhr.status === <span class="number">200</span>)&#123;</span><br><span class="line">			<span class="comment">// 成功</span></span><br><span class="line">			<span class="built_in">document</span>.write(xhr.responseText);</span><br><span class="line">			<span class="built_in">document</span>.write(<span class="string">'\n'</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">// 失败</span></span><br><span class="line">			<span class="built_in">document</span>.write(<span class="string">'失败\n'</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">document</span>.write(<span class="string">'还在请求中...\n'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解决跨域问题"><a href="#解决跨域问题" class="headerlink" title="解决跨域问题"></a>解决跨域问题</h2><blockquote>
<p>首先需要知道，什么是跨域？同一域有哪些条件？</p>
</blockquote>
<h3 id="一、什么是跨域"><a href="#一、什么是跨域" class="headerlink" title="一、什么是跨域"></a>一、什么是跨域</h3><p>下图是我在<code>http://localhost</code>(默认80端口)，去访问<code>http://localhost:3000/api/test</code>的数据接口，结果无法访问，就涉及到跨域问题。</p>
<p><img src="http://7xi72v.com1.z0.glb.clouddn.com/17-2-15/63081559-file_1487137267455_14420.png" alt=""></p>
<h3 id="二、同域条件"><a href="#二、同域条件" class="headerlink" title="二、同域条件"></a>二、同域条件</h3><ol>
<li>域名相同(<a href="http://ycjcl.cc和http://ycjcl.cc)是不一样的" target="_blank" rel="noopener">http://ycjcl.cc和http://ycjcl.cc)是不一样的</a></li>
<li>端口一样(<a href="http://localhost:80和http://localhost:3000)是不一样的" target="_blank" rel="noopener">http://localhost:80和http://localhost:3000)是不一样的</a> (可能少数浏览器支持端口不一致访问，毕竟极少)</li>
<li>协议一致(要么是https，要么是http)</li>
</ol>
<h3 id="三、解决方案"><a href="#三、解决方案" class="headerlink" title="三、解决方案"></a>三、解决方案</h3><h4 id="1、设置header头-cors-Access-Control-Allow-Origin"><a href="#1、设置header头-cors-Access-Control-Allow-Origin" class="headerlink" title="1、设置header头(cors)Access-Control-Allow-Origin: *"></a>1、设置header头(cors)<code>Access-Control-Allow-Origin: *</code></h4><p>此方法只需要在服务器端设置，<code>*</code>代表任意请求来源，如果只想让特定的域名访问，直接改成<code>http://example</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">'/api/test'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> json = &#123;</span><br><span class="line">		<span class="string">'title'</span>:<span class="string">'Kylin'</span>,</span><br><span class="line">		<span class="string">'Content'</span>:<span class="string">'AjaxTest'</span></span><br><span class="line">	&#125;;</span><br><span class="line">	res.header(<span class="string">'Access-Control-Allow-Origin'</span>,<span class="string">'*'</span>);</span><br><span class="line">	res.json(json);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="2、JSONP-服务器端-客户端"><a href="#2、JSONP-服务器端-客户端" class="headerlink" title="2、JSONP(服务器端+客户端):"></a>2、JSONP(服务器端+客户端):</h4><p><a href="https://zh.wikipedia.org/wiki/JSONP" target="_blank" rel="noopener">JSONP(JSON with Padding)解释</a>，</p>
<h5 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h5><p>如果是<code>Express</code>写得后台，可以使用JSONP封装方法<code>res.jsonp()</code>，其它语言/框架写得后台，转换方法就是将<code>data</code>转成<code>callback(data)</code>，用一个函数名callback(其它名也可以，需要和前端约定，默认为callback)将数据包起来，原理通过比较理解。</p>
<p>通过比较<code>res.json()</code>和<code>res.jsonp()</code>发现，<code>JSONP</code>是利用<code>&lt;script src=&quot;url&quot;&gt;&lt;/script&gt;</code>脚本可以跨域的特点，去访问外部资源。</p>
<p><img src="http://7xi72v.com1.z0.glb.clouddn.com/17-2-15/86025620-file_1487137267627_3397.png" alt=""></p>
<p>通过比较源码，差别如下：<br>1.增加了<code>callback</code>变量，<code>app.get(&#39;jsonp callback name&#39;)</code>值默认为<code>callback</code>，这行代码是获取<code>url地址上的?callback=</code>后面的回调函数名。</p>
<p><img src="http://7xi72v.com1.z0.glb.clouddn.com/17-2-15/92245160-file_1487137646413_5383.png" alt=""></p>
<p>2.源码中的<code>X-Content-Type-Options: nosniff</code>是用来增强安全性，防止<code>js</code>脚本被恶意执行。参考<a href="https://imququ.com/post/web-security-and-response-header.html#toc-3" target="_blank" rel="noopener">HTTP安全响应头 X-Content-Type-Options</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-Content-Type-Options" target="_blank" rel="noopener">MDN X-Content-Type-Options</a></p>
<p>3.后面代码<code>body = &#39;/**/ typeof &#39; + callback + &#39; === \&#39;function\&#39; &amp;&amp; &#39; + callback + &#39;(&#39; + body + &#39;);&#39;;</code>大致意思就是将<code>data</code>数据传成<code>callback(data)</code>这 种形式</p>
<h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><p>通过创建<code>script</code>标签去获取：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">"http://localhost:3000/api/test?callback=callback"</span>;</span><br><span class="line"><span class="comment">// 创建script标签，设置其属性</span></span><br><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">script.setAttribute(<span class="string">'src'</span>, url);</span><br><span class="line"><span class="comment">// 把script标签加入head，此时调用开始</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(script);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> callback =  <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> sum=<span class="string">''</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> data)&#123;</span><br><span class="line">        sum += data[<span class="string">'title'</span>];</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>].innerHTML = sum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="http://7xi72v.com1.z0.glb.clouddn.com/17-2-15/27783969-file_1487140563630_bdfb.png" alt=""></p>
<h3 id="3、Node服务器代理-服务器-："><a href="#3、Node服务器代理-服务器-：" class="headerlink" title="3、Node服务器代理(服务器)："></a>3、Node服务器代理(服务器)：</h3><p>就是开一个 node 服务，去代理请求，做一层转发，然后将前端放在 node 服务上。</p>
<h4 id="4、Fetch-客户端"><a href="#4、Fetch-客户端" class="headerlink" title="4、Fetch(客户端):"></a>4、Fetch(客户端):</h4><blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalFetch" target="_blank" rel="noopener">GlobalFetch</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" target="_blank" rel="noopener">FetchAPI</a>、<a href="https://www.w3ctech.com/topic/854?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">这个API很“迷人”</a></p>
</blockquote>
<p>新的 API 请求属性，使用也很简便，也能跨域。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myImage = <span class="built_in">document</span>.querySelector(<span class="string">'img'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myRequest = <span class="keyword">new</span> Request(<span class="string">'flowers.jpg'</span>);</span><br><span class="line"></span><br><span class="line">fetch(myRequest).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> response.blob();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> objectURL = URL.createObjectURL(response);</span><br><span class="line">  myImage.src = objectURL;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="5、postMessage"><a href="#5、postMessage" class="headerlink" title="5、postMessage"></a>5、postMessage</h4><p>主页面向子页面发请求：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">window</span>.frames[<span class="number">0</span>].postMessage(<span class="string">'hello'</span>,<span class="string">'http://ycjcl.cc'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子页面监听并响应信息：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(e.source!=<span class="built_in">window</span>.parent) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">var</span> hello=<span class="string">'world'</span>;</span><br><span class="line">    <span class="built_in">window</span>.parent.postMessage(hello,<span class="string">'*'</span>);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<h4 id="6、webpack-proxyTable-代理跨域"><a href="#6、webpack-proxyTable-代理跨域" class="headerlink" title="6、webpack proxyTable 代理跨域"></a>6、webpack proxyTable 代理跨域</h4><p>在 webpack 里直接配置 <code>proxyTable</code> 属性就行了，这样当访问 <code>/api</code> 时，实际上访问的是 <code>http://api.ycjcl.cc/info</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">proxyTable: &#123;</span><br><span class="line">      <span class="string">'/api'</span>: &#123;</span><br><span class="line">        target: <span class="string">'http://api.ycjcl.cc/info/'</span>,</span><br><span class="line">        changeOrigin: <span class="literal">true</span>,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          <span class="string">'^/api'</span>: <span class="string">''</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>文章有很多地方描述的可能不是很准确，提到的点也不够全面，如果有不对的地方，还望斧正！</p>
<blockquote>
<p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/AJAX/Getting_Started" target="_blank" rel="noopener">AJAX Getting_Started</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener">MDN XMLHttpRequest</a>、<a href="https://zh.wikipedia.org/wiki/JSONP" target="_blank" rel="noopener">维基百科JSONP</a>、<a href="http://www.cnblogs.com/zhouj/p/5818761.html" target="_blank" rel="noopener">HTTP状态码</a>、<a href="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434499861493e7c35be5e0864769a2c06afb4754acc6000" target="_blank" rel="noopener">廖大神AJAX教程</a>、<a href="http://www.jianshu.com/p/c94e49772123" target="_blank" rel="noopener">Ajax总结篇</a></p>
</blockquote>
</div></article></div></main><footer><div class="paginator"><a href="/2018/07/08/Module.exports和exports的区别/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2018 <a href="https://www.ycjcl.cc">Kylin King</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>